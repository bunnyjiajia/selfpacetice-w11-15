ปกติ
    // console.log('starting... ');
    // console.log('working... ');
    // console.log('ending...');
จะได้
    starting...
    working...
    ending...


asynchronous ด้วย setTimeout()
// console.log('starting... ');
// setTimeout(()=>console.log('working...'),3000)
// console.log('ending...');

ลำดับการทำงาน
    print: starting...
    ตั้ง timer 3 วินาที แต่ ยังไม่ทำงานทันที
    print: ending...
    หลัง 3 วินาที → print: working...

จะได้ 
    starting...
    ending...
    working...

ฟังก์ชัน doSomething() → เป็น Promise
function doSomething(hasResource) {
    return new Promise((resolve,reject)=>{
        setTimeout(()=>(hasResource ? resolve("done") : reject("fail")),5000)
    })
}
    ฟังก์ชันนี้คืนค่าเป็น Promise
    หลัง 5 วินาที:
    ถ้า hasResource = true → ให้ resolve("done")
    ถ้า false → reject("fail")
    เหมือนเป็นงานที่ต้องรอ 5 วิ แล้วตัดสินว่าจะสำเร็จมั้ย

แบบ async/await
async function working2() {
    console.log('starting...');
    try{
        const workStatus = await doSomething(false)
        console.log(workStatus);
        console.log('ending...'); 
    } catch (error){
        console.log(error);
    }
}
working2()
ลำดับการทำงาน
    print: starting...
    await doSomething(false) → รอ 5 วินาที เนื่องจาก false → promise reject("fail")
    กระโดดไป catch
    print: "fail"

จะได้
    starting...
    fail

ตัวอย่างเขียน Promise แบบ then/catch
// doSomething(false).then((result)=>{
//     console.log('working... ')
//     console.log(`work status = ${result}`)
//     console.log('ending...');
// }).catch((error)=>{
//     console.error('error จ้าาาา');
// })
ถ้า hasResource = false → จะเข้ามาที่ catch
จะได้ 
    error จ้าาาา
